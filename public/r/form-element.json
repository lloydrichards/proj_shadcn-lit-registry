{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "form-element",
  "type": "registry:lib",
  "title": "Form Element",
  "author": "Lloyd Richards <lloyd.d.richards@gmail.com>",
  "description": "Base class for form-associated custom elements with ElementInternals API support. Extends BaseElement with form validation, value management, and accessibility features for building custom form controls.",
  "dependencies": [],
  "registryDependencies": [
    "@lit/base-element"
  ],
  "files": [
    {
      "path": "registry/lib/form-element.ts",
      "content": "/**\n * FormElement - Base class for form-participating components\n *\n * Features:\n * 1. Native form participation via ElementInternals\n * 2. Validation API (checkValidity, reportValidity, setCustomValidity)\n * 3. Form submission and reset support\n * 4. Accessible by default with ARIA attributes\n */\n\nimport type { PropertyValues } from \"lit\";\nimport { property } from \"lit/decorators.js\";\nimport { BaseElement } from \"./base-element\";\n\n/**\n * Type for values that can be serialized in forms\n */\nexport type FormValue = string | number | boolean | null;\n\n/**\n * Types of validation errors\n */\nexport type ValidationType = \"valueMissing\" | \"custom\";\n\nexport interface FormElementProperties {\n  name?: string;\n  value?: FormValue;\n  defaultValue?: FormValue;\n  disabled?: boolean;\n  required?: boolean;\n  readonly?: boolean;\n  form?: string;\n  validationMessages?: Partial<Record<ValidationType, string>>;\n}\n\nexport abstract class FormElement\n  extends BaseElement\n  implements FormElementProperties\n{\n  // Enable native form participation (where supported)\n  static formAssociated = true;\n\n  // ElementInternals for native form participation\n  protected internals?: ElementInternals;\n\n  // Form element reference\n  private _form: HTMLFormElement | null = null;\n\n  // Form properties\n  @property({ type: String }) name = \"\";\n  @property() value: FormValue = \"\";\n  @property() defaultValue: FormValue = \"\";\n  @property({ type: Boolean, reflect: true }) disabled = false;\n  @property({ type: Boolean, reflect: true }) required = false;\n  @property({ type: Boolean, reflect: true }) readonly = false;\n  @property({ type: String }) form = \"\";\n  @property({ type: Object }) validationMessages?: Partial<\n    Record<ValidationType, string>\n  >;\n\n  // Validity state\n  protected validationMessage = \"\";\n  protected isValid = true;\n\n  constructor() {\n    super();\n\n    // Attach ElementInternals if available\n    if (\"attachInternals\" in this) {\n      this.internals = this.attachInternals();\n    }\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n\n    // Set default value on first connection\n    if (this.defaultValue === \"\") {\n      this.defaultValue = this.value;\n    }\n\n    // Find and attach to form\n    this._form = this._findForm();\n    if (this._form) {\n      this._form.addEventListener(\"submit\", this._handleFormSubmit);\n      this._form.addEventListener(\"reset\", this._handleFormReset);\n    }\n\n    // Update form value\n    this.updateFormValue();\n  }\n\n  override disconnectedCallback() {\n    super.disconnectedCallback();\n\n    // Cleanup form listeners\n    if (this._form) {\n      this._form.removeEventListener(\"submit\", this._handleFormSubmit);\n      this._form.removeEventListener(\"reset\", this._handleFormReset);\n    }\n  }\n\n  override updated(changedProperties: PropertyValues) {\n    super.updated(changedProperties);\n\n    // Update form value when value changes\n    if (changedProperties.has(\"value\")) {\n      this.updateFormValue();\n      this.checkValidity();\n    }\n\n    // Update validity when validation props change\n    if (\n      changedProperties.has(\"required\") ||\n      changedProperties.has(\"disabled\")\n    ) {\n      this.checkValidity();\n    }\n  }\n\n  /**\n   * Find the form this element belongs to\n   */\n  private _findForm(): HTMLFormElement | null {\n    // Check for form attribute (allows associating with a form by ID)\n    if (this.form) {\n      return document.getElementById(this.form) as HTMLFormElement;\n    }\n\n    // Use ElementInternals.form if available (preferred)\n    if (this.internals?.form) {\n      return this.internals.form;\n    }\n\n    // Fallback to closest form ancestor\n    return this.closest(\"form\");\n  }\n\n  /**\n   * Handle form submission - validate before allowing submit\n   */\n  private _handleFormSubmit = (event: Event) => {\n    if (!this.reportValidity()) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    }\n  };\n\n  /**\n   * Handle form reset - restore default value\n   */\n  private _handleFormReset = () => {\n    this.reset();\n  };\n\n  /**\n   * Check if a value is serializable for forms\n   */\n  private isSerializable(value: unknown): value is FormValue {\n    if (value === null) return true;\n    const type = typeof value;\n    return type === \"string\" || type === \"number\" || type === \"boolean\";\n  }\n\n  /**\n   * Update the form value using ElementInternals or hidden input\n   */\n  protected updateFormValue() {\n    const formValue = this.disabled ? null : this.value;\n\n    if (!this.isSerializable(formValue)) {\n      console.warn(\n        `FormElement \"${this.name}\": value must be string, number, boolean, or null, got ${typeof formValue}`,\n      );\n      return;\n    }\n\n    if (this.internals) {\n      // Use native form participation\n      if (formValue === null || formValue === undefined) {\n        this.internals.setFormValue(null);\n      } else {\n        this.internals.setFormValue(String(formValue));\n      }\n    }\n  }\n\n  /**\n   * Get localized validation message\n   */\n  private getValidationMessage(type: ValidationType): string {\n    const custom = this.validationMessages?.[type];\n    if (custom) return custom;\n\n    switch (type) {\n      case \"valueMissing\":\n        return \"Please fill out this field.\";\n      case \"custom\":\n        return this.validationMessage;\n      default:\n        return \"\";\n    }\n  }\n\n  /**\n   * Check validity without showing error message\n   */\n  checkValidity(): boolean {\n    if (this.disabled) {\n      this.isValid = true;\n      this.validationMessage = \"\";\n      return true;\n    }\n\n    // Check custom validity first (if set, it takes precedence)\n    if (this.validationMessage && !this.isValid) {\n      // Custom validity is already set, don't override\n      return false;\n    }\n\n    // Check required\n    if (this.required && !this.value) {\n      this.isValid = false;\n      this.validationMessage = this.getValidationMessage(\"valueMissing\");\n    } else {\n      this.isValid = true;\n      this.validationMessage = \"\";\n    }\n\n    // Update ElementInternals validity\n    if (this.internals) {\n      if (this.isValid) {\n        this.internals.setValidity({});\n      } else {\n        this.internals.setValidity(\n          { valueMissing: this.required && !this.value },\n          this.validationMessage,\n        );\n      }\n    }\n\n    return this.isValid;\n  }\n\n  /**\n   * Check validity and show error message\n   */\n  reportValidity(): boolean {\n    const isValid = this.checkValidity();\n\n    if (!isValid) {\n      this.emit(\"invalid\", {\n        message: this.validationMessage,\n        validity: this.validity,\n      });\n\n      // Could also show a tooltip or other UI here\n      this.internals?.reportValidity();\n    }\n\n    return isValid;\n  }\n\n  /**\n   * Set a custom validation message\n   */\n  setCustomValidity(message: string): void {\n    this.validationMessage = message;\n    this.isValid = !message;\n\n    if (this.internals) {\n      if (message) {\n        this.internals.setValidity({ customError: true }, message);\n      } else {\n        this.internals.setValidity({});\n      }\n    }\n  }\n\n  /**\n   * Get validity state\n   */\n  get validity(): ValidityState {\n    if (this.internals) {\n      return this.internals.validity;\n    }\n\n    // Polyfill ValidityState\n    return {\n      badInput: false,\n      customError: !!this.validationMessage,\n      patternMismatch: false,\n      rangeOverflow: false,\n      rangeUnderflow: false,\n      stepMismatch: false,\n      tooLong: false,\n      tooShort: false,\n      typeMismatch: false,\n      valid: this.isValid,\n      valueMissing: this.required && !this.value,\n    } as ValidityState;\n  }\n\n  /**\n   * Reset to default value\n   */\n  reset(): void {\n    this.value = this.defaultValue;\n    this.validationMessage = \"\";\n    this.isValid = true;\n    this.requestUpdate();\n  }\n\n  /**\n   * Get the form element this control belongs to\n   */\n  get formElement(): HTMLFormElement | null {\n    if (this.internals) {\n      return this.internals.form;\n    }\n\n    if (this.form) {\n      return document.getElementById(this.form) as HTMLFormElement;\n    }\n\n    return this.closest(\"form\");\n  }\n\n  /**\n   * Focus the primary input/control element\n   * Should focus the internal focusable element (shadow DOM or light DOM),\n   * not the custom element itself\n   *\n   * @example\n   * focus(options?: FocusOptions) {\n   *   this._input?.focus(options);\n   * }\n   */\n  abstract focus(options?: FocusOptions): void;\n\n  /**\n   * Remove focus from the control\n   *\n   * @example\n   * blur() {\n   *   this._input?.blur();\n   * }\n   */\n  abstract blur(): void;\n\n  /**\n   * Helper to focus an element with enhanced semantics\n   * @protected\n   */\n  protected focusElement(\n    element: HTMLElement | null | undefined,\n    options?: FocusOptions,\n  ) {\n    if (element) {\n      element.focus(options);\n    }\n  }\n\n  /**\n   * Helper to blur an element\n   * @protected\n   */\n  protected blurElement(element: HTMLElement | null | undefined) {\n    if (element) {\n      element.blur();\n    }\n  }\n\n  /**\n   * Label delegation support\n   * Allows external labels with for=\"id\" to trigger the control\n   */\n  private _labelClickHandler?: (e: Event) => void;\n\n  /**\n   * Setup label delegation for this form control\n   * Call this in connectedCallback() to enable clicking labels to activate the control\n   *\n   * @param onClick - Callback function to execute when label is clicked\n   * @protected\n   *\n   * @example\n   * override connectedCallback() {\n   *   super.connectedCallback();\n   *   this.setupLabelDelegation(() => this._handleClick());\n   * }\n   */\n  protected setupLabelDelegation(onClick: () => void) {\n    if (!this.id) return;\n\n    const handler = (e: Event) => {\n      const label = e.currentTarget as HTMLLabelElement;\n      if (label.htmlFor === this.id && !this.disabled) {\n        e.preventDefault();\n        onClick();\n      }\n    };\n\n    this._labelClickHandler = handler;\n\n    const root = this.getRootNode() as Document | ShadowRoot;\n    const labels = root.querySelectorAll(\n      `label[for=\"${this.id}\"]`,\n    ) as NodeListOf<HTMLLabelElement>;\n    labels.forEach((label) => {\n      label.addEventListener(\"click\", handler);\n    });\n  }\n\n  /**\n   * Cleanup label delegation listeners\n   * Call this in disconnectedCallback() to prevent memory leaks\n   *\n   * @protected\n   *\n   * @example\n   * override disconnectedCallback() {\n   *   super.disconnectedCallback();\n   *   this.cleanupLabelDelegation();\n   * }\n   */\n  protected cleanupLabelDelegation() {\n    const handler = this._labelClickHandler;\n    if (!this.id || !handler) return;\n\n    const root = this.getRootNode() as Document | ShadowRoot;\n    const labels = root.querySelectorAll(\n      `label[for=\"${this.id}\"]`,\n    ) as NodeListOf<HTMLLabelElement>;\n    labels.forEach((label) => {\n      label.removeEventListener(\"click\", handler);\n    });\n  }\n\n  /**\n   * Re-setup label delegation when the id changes\n   * Call this in updated() when the id property changes\n   *\n   * @protected\n   *\n   * @example\n   * override updated(changedProperties: PropertyValues) {\n   *   super.updated(changedProperties);\n   *   if (changedProperties.has(\"id\")) {\n   *     this.updateLabelDelegation();\n   *   }\n   * }\n   */\n  protected updateLabelDelegation() {\n    this.cleanupLabelDelegation();\n    // Re-setup will happen on next update since we need the new id\n    // Components should call setupLabelDelegation in their updated() if id changed\n  }\n}\n\nexport default FormElement;\n",
      "type": "registry:lib"
    }
  ],
  "categories": [
    "lib",
    "form",
    "infrastructure",
    "web-component"
  ]
}