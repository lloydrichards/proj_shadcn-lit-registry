{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "focus-trap-controller",
  "type": "registry:lib",
  "title": "Focus Trap Controller",
  "author": "Lloyd Richards <lloyd.d.richards@gmail.com>",
  "description": "Reactive controller for trapping focus within a container for modal dialogs and overlays. Features Tab/Shift+Tab cycling, auto-focus first element, restore focus on deactivation, and handles empty containers gracefully.",
  "dependencies": [],
  "files": [
    {
      "path": "registry/controllers/focus-trap-controller.ts",
      "content": "/**\n * FocusTrapController - Reactive controller for focus trap management\n *\n * Provides reusable logic for trapping focus within a container element.\n * When active, Tab/Shift+Tab cycles through focusable elements within the container.\n *\n * Used by: dialog, potentially other modal components\n */\n\nimport type { ReactiveController, ReactiveControllerHost } from \"lit\";\nimport { getFocusableElements } from \"../lib/utils\";\n\n/**\n * Configuration options for the FocusTrapController\n */\nexport interface FocusTrapConfig {\n  /**\n   * Function to get the container element where focus should be trapped\n   * Should return null/undefined when focus trap should not be active\n   */\n  getContainer: () => HTMLElement | null | undefined;\n\n  /**\n   * Function to check if the focus trap should be active\n   * @default () => true\n   */\n  isActive?: () => boolean;\n\n  /**\n   * Whether to auto-focus the first focusable element when trap activates\n   * @default true\n   */\n  autoFocus?: boolean;\n\n  /**\n   * Whether to restore focus to previously focused element when trap deactivates\n   * @default true\n   */\n  restoreFocus?: boolean;\n}\n\n/**\n * Reactive controller for focus trap management\n *\n * @example\n * ```typescript\n * export class Dialog extends BaseElement {\n *   @property({ type: Boolean }) open = false;\n *   @query('[role=\"dialog\"]') dialogElement?: HTMLElement;\n *\n *   private focusTrap = new FocusTrapController(this, {\n *     getContainer: () => this.dialogElement,\n *     isActive: () => this.open,\n *   });\n *\n *   override updated(changed: PropertyValues) {\n *     super.updated(changed);\n *     if (changed.has('open')) {\n *       this.focusTrap.update();\n *     }\n *   }\n * }\n * ```\n */\nexport class FocusTrapController implements ReactiveController {\n  private config: Required<FocusTrapConfig>;\n  private isTrapping = false;\n  private previousFocus: HTMLElement | null = null;\n\n  constructor(host: ReactiveControllerHost, config: FocusTrapConfig) {\n    this.config = {\n      isActive: () => true,\n      autoFocus: true,\n      restoreFocus: true,\n      ...config,\n    };\n    host.addController(this);\n  }\n\n  hostConnected(): void {\n    // Controller is ready\n  }\n\n  hostDisconnected(): void {\n    this.deactivate();\n  }\n\n  private handleKeyDown = (e: KeyboardEvent): void => {\n    if (e.key !== \"Tab\") return;\n\n    const container = this.config.getContainer();\n    if (!container) return;\n\n    const focusableElements = getFocusableElements(container);\n    if (focusableElements.length === 0) return;\n\n    const firstElement = focusableElements[0];\n    const lastElement = focusableElements[focusableElements.length - 1];\n\n    if (e.shiftKey) {\n      // Shift + Tab - moving backwards\n      if (document.activeElement === firstElement) {\n        lastElement.focus();\n        e.preventDefault();\n      }\n    } else {\n      // Tab - moving forwards\n      if (document.activeElement === lastElement) {\n        firstElement.focus();\n        e.preventDefault();\n      }\n    }\n  };\n\n  /**\n   * Activate the focus trap\n   */\n  private activate(): void {\n    if (this.isTrapping) return;\n\n    const container = this.config.getContainer();\n    if (!container) return;\n\n    if (\n      this.config.restoreFocus &&\n      document.activeElement instanceof HTMLElement\n    ) {\n      this.previousFocus = document.activeElement;\n    }\n\n    container.addEventListener(\"keydown\", this.handleKeyDown);\n    this.isTrapping = true;\n\n    if (this.config.autoFocus) {\n      const focusableElements = getFocusableElements(container);\n      if (focusableElements.length > 0) {\n        const autofocusElement = focusableElements.find((el) =>\n          el.hasAttribute(\"autofocus\"),\n        );\n        if (autofocusElement) {\n          autofocusElement.focus();\n        } else {\n          focusableElements[0].focus();\n        }\n      } else {\n        // No focusable elements - focus container itself\n        container.focus();\n      }\n    }\n  }\n\n  /**\n   * Deactivate the focus trap\n   */\n  private deactivate(): void {\n    if (!this.isTrapping) return;\n\n    const container = this.config.getContainer();\n    if (container) {\n      container.removeEventListener(\"keydown\", this.handleKeyDown);\n    }\n\n    this.isTrapping = false;\n\n    if (this.config.restoreFocus && this.previousFocus) {\n      this.previousFocus.focus();\n      this.previousFocus = null;\n    }\n  }\n\n  update(): void {\n    if (this.config.isActive()) {\n      this.activate();\n    } else {\n      this.deactivate();\n    }\n  }\n\n  start(): void {\n    this.activate();\n  }\n  stop(): void {\n    this.deactivate();\n  }\n\n  get active(): boolean {\n    return this.isTrapping;\n  }\n}\n\nexport default FocusTrapController;\n",
      "type": "registry:lib"
    }
  ],
  "categories": [
    "lib",
    "controller",
    "web-component"
  ]
}