{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tailwind-mixin",
  "type": "registry:lib",
  "title": "Tailwind Mixin",
  "author": "Lloyd Richards <lloyd.d.richards@gmail.com>",
  "description": "A set of Tailwind CSS mixins for Lit components, enabling easy integration of Tailwind styles within web components.",
  "dependencies": [
    "tailwind-merge",
    "tw-animate-css",
    "class-variance-authority",
    "clsx"
  ],
  "files": [
    {
      "path": "registry/lib/tailwindMixin.ts",
      "content": "import { adoptStyles, type LitElement, unsafeCSS } from \"lit\";\nimport tailwindCss from \"../styles/tailwind.global.css?inline\";\n\ndeclare global {\n  // biome-ignore lint/suspicious/noExplicitAny: Required for mixin pattern compatibility\n  export type LitMixin<T = unknown> = new (...args: any[]) => T & LitElement;\n}\n\nexport const tailwind = unsafeCSS(tailwindCss);\n\n// https://github.com/tailwindlabs/tailwindcss/issues/15005\n// Set all @property values from tailwind on the document\n// And only do this once (check if there is already a stylesheet with the same content)\nif (\n  tailwind.styleSheet &&\n  document?.adoptedStyleSheets &&\n  !document.adoptedStyleSheets.some(\n    (sheet) =>\n      sheet.cssRules[0]?.cssText === tailwind.styleSheet?.cssRules[0].cssText,\n  )\n) {\n  const propertiesSheet = new CSSStyleSheet();\n  let code = tailwind.cssText;\n  code = code\n    .replaceAll(\"inherits: false\", \"inherits: true\")\n    .substring(code.indexOf(\"@property\"));\n  propertiesSheet.replaceSync(code);\n  document.adoptedStyleSheets.push(propertiesSheet);\n}\n\nexport const TW = <T extends LitMixin>(superClass: T): T =>\n  class extends superClass {\n    connectedCallback() {\n      super.connectedCallback();\n      if (this.shadowRoot) adoptStyles(this.shadowRoot, [tailwind]);\n    }\n  };\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/tailwindMixin.d.ts",
      "content": "import { type LitElement } from \"lit\";\ndeclare global {\n  // biome-ignore lint/suspicious/noExplicitAny: Mixin constructor requires any for class constructor args\n  export type LitMixin<T = unknown> = new (...args: any[]) => T & LitElement;\n}\nexport declare const TW: <T extends LitMixin>(superClass: T) => T;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/lib/utils.ts",
      "content": "import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\n/**\n * Merge Tailwind classes with conflict resolution\n */\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n/**\n * Create a unique ID\n */\nexport function uid(): string {\n  return Math.random().toString(36).substring(2, 11);\n}\n\n/**\n * Check if element is focusable\n */\nexport function isFocusable(element: Element): boolean {\n  if (!(element instanceof HTMLElement)) return false;\n\n  if (element.tabIndex >= 0) return true;\n\n  const focusableTags = [\"BUTTON\", \"INPUT\", \"SELECT\", \"TEXTAREA\", \"A\", \"AREA\"];\n\n  if (focusableTags.includes(element.tagName)) {\n    return !element.hasAttribute(\"disabled\");\n  }\n\n  return false;\n}\n\n/**\n * Get all focusable elements within container\n */\nexport function getFocusableElements(container: HTMLElement): HTMLElement[] {\n  const elements = container.querySelectorAll<HTMLElement>(\n    \"button:not([disabled]), \" +\n      \"[href], \" +\n      \"input:not([disabled]), \" +\n      \"select:not([disabled]), \" +\n      \"textarea:not([disabled]), \" +\n      '[tabindex]:not([tabindex=\"-1\"])',\n  );\n\n  return Array.from(elements).filter((el) => {\n    // Skip hidden elements\n    const style = getComputedStyle(el);\n    return style.display !== \"none\" && style.visibility !== \"hidden\";\n  });\n}\n\n/**\n * Trap focus within container\n */\nexport function trapFocus(container: HTMLElement) {\n  const focusableElements = getFocusableElements(container);\n  if (focusableElements.length === 0) return;\n\n  const firstElement = focusableElements[0];\n  const lastElement = focusableElements[focusableElements.length - 1];\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if (e.key !== \"Tab\") return;\n\n    if (e.shiftKey) {\n      // Shift + Tab\n      if (document.activeElement === firstElement) {\n        lastElement.focus();\n        e.preventDefault();\n      }\n    } else {\n      // Tab\n      if (document.activeElement === lastElement) {\n        firstElement.focus();\n        e.preventDefault();\n      }\n    }\n  };\n\n  container.addEventListener(\"keydown\", handleKeyDown);\n\n  // Return cleanup function\n  return () => {\n    container.removeEventListener(\"keydown\", handleKeyDown);\n  };\n}\n\n/**\n * Debounce function calls\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  fn: T,\n  delay: number,\n): (...args: Parameters<T>) => void {\n  let timeoutId: ReturnType<typeof setTimeout>;\n\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn(...args), delay);\n  };\n}\n\n/**\n * Throttle function calls\n */\nexport function throttle<T extends (...args: any[]) => any>(\n  fn: T,\n  delay: number,\n): (...args: Parameters<T>) => void {\n  let lastCall = 0;\n\n  return (...args: Parameters<T>) => {\n    const now = Date.now();\n    if (now - lastCall >= delay) {\n      lastCall = now;\n      fn(...args);\n    }\n  };\n}\n\n/**\n * Check if an element has slotted content\n * Useful for conditional rendering based on slot presence\n *\n * Note: For reactive slot detection, prefer using @queryAssignedElements decorator\n *\n * @param host - The host element (custom element)\n * @param slotName - The slot name to check (empty string for default slot)\n * @returns true if the slot has content, false otherwise\n *\n * @example\n * // Check default slot\n * if (hasSlottedContent(this)) {\n *   // Render something\n * }\n *\n * @example\n * // Check named slot\n * if (hasSlottedContent(this, 'prefix')) {\n *   // Render prefix wrapper\n * }\n */\nexport function hasSlottedContent(host: Element, slotName = \"\"): boolean {\n  if (slotName) {\n    // Check for elements with matching slot attribute\n    return host.querySelector(`[slot=\"${slotName}\"]`) !== null;\n  }\n\n  // Check for default slot content (elements without slot attribute + text nodes)\n  return Array.from(host.childNodes).some((node) => {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      return !(node as Element).hasAttribute(\"slot\");\n    }\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node.textContent?.trim() !== \"\";\n    }\n    return false;\n  });\n}\n\nexport default {\n  cn,\n  uid,\n  isFocusable,\n  getFocusableElements,\n  trapFocus,\n  debounce,\n  throttle,\n  hasSlottedContent,\n};\n",
      "type": "registry:lib"
    }
  ],
  "docs": "IMPORTANT: You must create a Tailwind CSS global file. See setup instructions at https://lit-registry.lloydrichards.dev or copy the template from https://github.com/lloydrichards/shadcn-lit-registry/blob/main/registry/styles/tailwind.global.css",
  "categories": [
    "ui",
    "web-component"
  ]
}