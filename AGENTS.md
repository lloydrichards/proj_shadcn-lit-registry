# AGENTS.md

> **Note:** This file is the authoritative source for coding agent instructions.
> If in doubt, prefer AGENTS.md over README.md.

## üö¶ Quick Reference

- **Install dependencies:** `bun install`
- **Start Next.js dev server:** `bun run dev`
- **Start Storybook:** `bun run storybook`
- **Build for production:** `bun run build` (builds Next.js + Storybook)
- **Build registry:** `bun run registry:build`
- **Run tests:** `bun run test`
- **Lint code:** `bun run lint`
- **Format code:** `bun run format`
- **Search code:** `rg "pattern"`
- **Add package:** `bun add <package-name>`

---

This file provides comprehensive guidance for coding agents when working with
the **Shadcn Lit Component Registry** - a component registry for Lit-based web
components designed to work seamlessly with the shadcn CLI.

## Core Development Philosophy

### KISS (Keep It Simple, Stupid)

Simplicity should be a key goal in design. Choose straightforward solutions over
complex ones whenever possible. Simple solutions are easier to understand,
maintain, and debug.

### YAGNI (You Aren't Gonna Need It)

Avoid building functionality on speculation. Implement features only when they
are needed, not when you anticipate they might be useful in the future.

### HTML-first

Prioritize HTML structure and semantics in your components. Use native HTML
elements with proper ARIA attributes when needed. Shadow DOM provides
encapsulation, but your markup should still be semantic and accessible.

### Design Principles

- **Component Encapsulation**: Use Shadow DOM for style and DOM isolation
- **Reactive Properties**: Leverage Lit's reactive system for automatic updates
- **Type Safety**: Use TypeScript with decorators for compile-time correctness
- **Single Responsibility**: Each component should have one clear purpose
- **Composability**: Build complex UIs by composing simple, reusable components

## üß± Project Structure & Architecture

This is a **component registry** for Lit-based web components designed to work
with the shadcn CLI. It consists of:

1. **Next.js website** - Documentation and registry browser (app/)
2. **Lit components** - Reusable web components (registry/)
3. **Storybook** - Component development and documentation (.storybook/)
4. **Registry system** - JSON-based component definitions (registry.json)

### Key Directories

- **app/** - Next.js application (React)
- **registry/** - Lit component source (Web Components)
  - **registry/lib/** - Shared utilities (tailwindMixin.ts, utils.ts)
  - **@/controllers/** - Reusable Lit reactive controllers
  - **registry/ui/** - UI components (_.ts, _.stories.ts)
  - **registry/styles/** - Tailwind config (tailwind.global.css)
- **.storybook/** - Storybook configuration
- **public/r/** - Built registry JSON files (generated by
  `bun run registry:build`)

### Key Files

- **registry.json**: Source of truth for all components in the registry
- **registry/lib/tailwindMixin.ts**: Required mixin to apply Tailwind to Shadow
  DOM
- **registry/lib/utils.ts**: Helper functions like `cn()` for class merging
- **registry/styles/tailwind.global.css**: Tailwind v4 configuration with
  `@theme`
- **app/registry/[name]/route.ts**: Dynamic API route for serving registry items

## Lit & Web Components

### Quick Reference

**IMPORTANT:** Use Context7 or WebFetch for detailed Lit documentation when
needed:

- **Lit Docs**: https://lit.dev/docs/
- **Web Components MDN**:
  https://developer.mozilla.org/en-US/docs/Web/API/Web_components

### Component Structure Template

```typescript
import { LitElement, html } from "lit";
import { customElement, property, state } from "lit/decorators.js";
import { cva, type VariantProps } from "class-variance-authority";
import { TW } from "@/registry/lib/tailwindMixin";
import { cn } from "@/registry/lib/utils";

const TwLitElement = TW(LitElement);

const variants = cva("base-styles", {
  variants: {
    variant: { default: "...", secondary: "..." },
    size: { default: "...", lg: "..." },
  },
  defaultVariants: { variant: "default", size: "default" },
});

export interface MyComponentProperties {
  variant?: VariantProps<typeof variants>["variant"];
  disabled?: boolean;
}

@customElement("ui-my-component")
export class MyComponent extends TwLitElement implements MyComponentProperties {
  @property({ type: String }) variant: MyComponentProperties["variant"] =
    "default";
  @property({ type: Boolean }) disabled = false;
  @state() private _internalState = "";

  render() {
    return html`
      <div class=${cn(variants({ variant: this.variant }))}>
        <slot></slot>
      </div>
    `;
  }

  private _handleEvent() {
    this.dispatchEvent(
      new CustomEvent("my-event", {
        detail: { value: "data" },
        bubbles: true,
        composed: true, // CRITICAL: Cross shadow boundary
      })
    );
  }
}

declare global {
  interface HTMLElementTagNameMap {
    "ui-my-component": MyComponent;
  }
}
```

### Critical Lit Concepts

- **Always extend TwLitElement** (not LitElement) for Tailwind support
- **Always call super.connectedCallback()** in lifecycle methods
- **Use @property()** for reactive public props, **@state()** for internal state
- **Set composed: true** on CustomEvents to cross shadow DOM boundary
- **Declare custom elements** in HTMLElementTagNameMap for TypeScript

## Registry System

### How It Works

1. **Define in registry.json** - Add component metadata, files, dependencies
2. **Build** - Run `bun run registry:build` to generate JSON files in
   `public/r/`
3. **Install** - Users run `npx shadcn@latest add @lit/component-name`

### Registry Entry Template

```json
{
  "name": "my-component",
  "type": "registry:component",
  "title": "My Component",
  "description": "Component description",
  "categories": ["ui", "web-component"],
  "author": "Your Name <your.email@example.com>",
  "dependencies": ["lucide-static"],
  "files": [
    { "path": "registry/ui/my-component.ts", "type": "registry:ui" },
    { "path": "registry/ui/my-component.stories.ts", "type": "registry:ui" }
  ]
}
```

## Tailwind CSS v4 Integration

### Shadow DOM Integration

**CRITICAL**: Tailwind v4 requires special setup for Shadow DOM using the TW
mixin.

**The TW Mixin (registry/lib/tailwindMixin.ts):**

```typescript
import { adoptStyles, type LitElement, unsafeCSS } from "lit";
import tailwindCss from "../styles/tailwind.global.css?inline";

export const TW = <T extends LitMixin>(superClass: T): T =>
  class extends superClass {
    connectedCallback() {
      super.connectedCallback();
      if (this.shadowRoot) adoptStyles(this.shadowRoot, [tailwind]);
    }
  };
```

**Usage in Components:**

```typescript
import { TW } from "@/registry/lib/tailwindMixin";
const TwLitElement = TW(LitElement);

@customElement("my-component")
export class MyComponent extends TwLitElement {}
```

### Utility Functions

**cn() - Merge Tailwind classes:**

```typescript
import { cn } from '@/registry/lib/utils';

render() {
  return html`
    <div class=${cn('base-class', this.active && 'active-class')}>
      Content
    </div>
  `;
}
```

### Host Class Forwarding Pattern

**CRITICAL**: When creating components that wrap content in a shadow DOM
element, you **must** forward classes from the host element to the inner element
using `this.className`. This allows users to apply utility classes (like `w-96`,
`max-w-md`, etc.) to the component.

**Why this is needed:**

- Tailwind utility classes applied to the custom element host (e.g.,
  `<ui-card class="w-96">`) cannot be styled by Tailwind CSS inside the shadow
  DOM
- Shadow DOM styles are isolated and cannot access classes on the host element
- The solution is to copy `this.className` to the inner wrapper element

**Pattern:**

```typescript
import { cn } from "@/lib/utils";

@customElement("ui-my-component")
export class MyComponent extends TW(LitElement) {
  render() {
    return html`
      <div class=${cn("base-styles", this.className)}>
        <slot></slot>
      </div>
    `;
  }
}
```

**Example - Before (broken):**

```typescript
// ‚ùå User's width class won't work
render() {
  return html`
    <div class="bg-card rounded-xl border">
      <slot></slot>
    </div>
  `;
}
// Usage: <ui-card class="w-96"> - w-96 has NO effect
```

**Example - After (working):**

```typescript
// ‚úÖ User's width class is forwarded to inner div
render() {
  return html`
    <div class=${cn("bg-card rounded-xl border", this.className)}>
      <slot></slot>
    </div>
  `;
}
// Usage: <ui-card class="w-96"> - w-96 works correctly
```

**When to apply this pattern:**

- ALL components that render a wrapper element in shadow DOM
- Components where users might want to apply layout classes (width, height,
  margin, etc.)
- Both parent components and sub-components (e.g., `ui-card`, `ui-card-header`,
  etc.)

**When NOT to apply:**

- Components using `display: contents` (classes apply directly to slotted
  content)
- Components that render `<slot></slot>` directly without a wrapper

### Dark Mode

**Setup (registry/styles/tailwind.global.css):**

```css
@import "tailwindcss";
@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--_background);
}

@layer base {
  :root,
  :host {
    --_background: var(--background, oklch(1 0 0));
  }
  .dark,
  :host(.dark),
  :host-context(.dark) {
    --_background: var(--background, oklch(0.147 0.004 49.25));
  }
}
```

**Tailwind v4 Docs**: Use WebFetch for https://tailwindcss.com/docs when needed

## Storybook Development

**IMPORTANT:** Use Context7 or WebFetch for detailed Storybook docs when needed:

- **Storybook Docs**: https://storybook.js.org/docs

### Story Template

```typescript
import "./my-component";
import type { Meta, StoryObj } from "@storybook/web-components-vite";
import { html } from "lit";
import type { MyComponentProperties } from "./my-component";

type MyComponentArgs = MyComponentProperties & { children?: string };

const meta: Meta<MyComponentArgs> = {
  title: "ui/MyComponent",
  component: "ui-my-component",
  tags: ["autodocs"],
  argTypes: {
    variant: { control: "select", options: ["default", "secondary"] },
  },
  args: { variant: "default", children: "Content" },
  render: (args) => html`
    <ui-my-component .variant=${args.variant}>
      ${args.children}
    </ui-my-component>
  `,
};

export default meta;
type Story = StoryObj<MyComponentArgs>;

export const Default: Story = {};
export const Secondary: Story = { args: { variant: "secondary" } };
```

### Commands

```bash
bun run storybook        # Start Storybook dev server on port 6006
bun run storybook:build  # Build static Storybook
```

## State Management

**This project does NOT use Effect or Effect-Atom**. Use Lit's built-in
reactivity:

```typescript
@customElement("my-counter")
export class MyCounter extends TwLitElement {
  @state() private _count = 0;

  private _increment() {
    this._count++;
  }

  render() {
    return html`
      <button @click=${this._increment}>Count: ${this._count}</button>
    `;
  }
}
```

## Reactive Controllers

**Reactive Controllers** are a Lit pattern for encapsulating reusable behavior.
This project uses controllers extensively to eliminate code duplication and
ensure consistent behavior across components.

### Available Controllers

#### 1. MenuNavigationController

**Purpose**: Keyboard navigation for menu-like components (dropdowns, context
menus, selects).

**Location**: `@/controllers/menu-navigation-controller.ts`

**Features**:

- Arrow key navigation (Up/Down or Left/Right based on orientation)
- Home/End key support
- Enter/Space to select
- Escape key handling
- Typeahead search (500ms timeout)
- Loop support (wrap around)

**Usage Pattern**:

```typescript
import { MenuNavigationController } from "@/controllers/menu-navigation-controller";

export class DropdownMenuContent extends BaseElement {
  @state() private highlightedIndex = -1;
  @property({ type: Boolean }) loop = false;

  private navigation = new MenuNavigationController(this, {
    getItems: () => this.getNavigableItems(),
    getHighlightedIndex: () => this.highlightedIndex,
    setHighlightedIndex: (index) => {
      this.highlightedIndex = index;
    },
    onSelect: (item) => item.click(),
    onEscape: () => {
      this.close();
    },
    loop: () => this.loop, // Reactive getter for runtime updates
    orientation: "vertical", // or "horizontal"
  });

  override willUpdate(changed: PropertyValues) {
    super.willUpdate(changed);
    // Update highlighted state when index changes
    if (changed.has("highlightedIndex")) {
      const items = this.getNavigableItems();
      items.forEach((item, index) => {
        item.highlighted = index === this.highlightedIndex;
      });
    }
  }

  override updated(changed: PropertyValues) {
    super.updated(changed);
    // Reset navigation when menu closes
    if (changed.has("isOpen") && !this.isOpen) {
      this.navigation.reset();
    }
  }

  private handleKeyDown = (e: KeyboardEvent) => {
    this.navigation.handleKeyDown(e);
  };
}
```

**Used by**: dropdown-menu, context-menu, menubar, select

#### 2. ClickAwayController

**Purpose**: Detect clicks outside a component and trigger a callback.

**Location**: `@/controllers/click-away-controller.ts`

**Features**:

- Click-outside detection
- Multiple excluded elements support
- Conditional activation via `isActive`
- Capture vs bubbling phase control
- Automatic setTimeout delay to prevent immediate triggers

**Usage Pattern**:

```typescript
import { ClickAwayController } from "@/controllers/click-away-controller";

export class DropdownMenu extends BaseElement {
  @property({ type: Boolean }) open = false;

  private clickAway = new ClickAwayController(this, {
    onClickAway: () => {
      this.open = false;
    },
    isActive: () => this.open,
    excludeElements: () => {
      const content = this.querySelector("ui-dropdown-menu-content");
      return content ? [content] : [];
    },
    useCapture: false, // Set to true for context menus
  });

  override updated(changed: PropertyValues) {
    super.updated(changed);
    if (changed.has("open")) {
      this.clickAway.update();
    }
  }
}
```

**Used by**: dropdown-menu, context-menu, menubar, select

#### 3. FocusTrapController

**Purpose**: Trap focus within a container for modal dialogs and overlays.

**Location**: `@/controllers/focus-trap-controller.ts`

**Features**:

- Tab/Shift+Tab cycles through focusable elements
- Auto-focus first element (with autofocus attribute support)
- Restore focus to previous element on deactivation
- Handles empty containers gracefully
- Configurable via `isActive` flag

**Usage Pattern**:

```typescript
import { FocusTrapController } from "@/controllers/focus-trap-controller";

export class Dialog extends BaseElement {
  @property({ type: Boolean }) open = false;
  @query("dialog") dialogElement?: HTMLDialogElement;

  private focusTrap = new FocusTrapController(this, {
    getContainer: () => this.dialogElement,
    isActive: () => this.open,
    autoFocus: true,
    restoreFocus: true,
  });

  override updated(changed: PropertyValues) {
    super.updated(changed);
    if (changed.has("open")) {
      this.focusTrap.update();
    }
  }
}
```

**Used by**: dialog

### Controller Best Practices

**‚úÖ DO:**

- Keep controllers **stateless** - state belongs in the host component
- Use `@state()` in host for reactive properties
- Call `controller.update()` in `updated()` lifecycle
- Use getter functions for reactive config (`loop: () => this.loop`)
- Clean up properly in `disconnectedCallback()` (controllers do this
  automatically)

**‚ùå DON'T:**

- Store state in controllers (use host's `@state()` instead)
- Call `host.requestUpdate()` from controllers (triggers full re-render)
- Forget to update controller when host state changes
- Use static values when reactive getters are available

### Creating New Controllers

When creating a new controller, follow this pattern:

```typescript
import type { ReactiveController, ReactiveControllerHost } from "lit";

export interface MyControllerConfig {
  // Configuration interface
}

export class MyController implements ReactiveController {
  private host: ReactiveControllerHost;
  private config: Required<MyControllerConfig>;

  constructor(host: ReactiveControllerHost, config: MyControllerConfig) {
    this.config = {
      // Defaults
      ...config,
    };
    host.addController(this);
  }

  hostConnected(): void {
    // Setup when host connects
  }

  hostDisconnected(): void {
    // Cleanup when host disconnects
  }
}
```

**Controller Testing**: All controllers should have comprehensive unit tests in
`@/controllers/*.test.ts` using Vitest.

## Testing Strategy

```bash
bun run test              # Run all tests with Vitest
bun run storybook         # Storybook includes test UI
```

**Vitest Docs**: Use WebFetch for https://vitest.dev/ when needed

## TypeScript Configuration

**CRITICAL settings in tsconfig.json:**

- `experimentalDecorators: true` - Required for Lit
- `useDefineForClassFields: false` - Required for Lit reactive properties

## Style & Conventions

### Naming Conventions

- **Custom element names**: `kebab-case` with hyphen (e.g., `ui-button`)
- **Class names**: `PascalCase` (e.g., `class Button`)
- **File names**: `kebab-case.ts` (e.g., `button.ts`)
- **Public methods**: `camelCase` (e.g., `open()`)
- **Private methods**: `_camelCase` with underscore (e.g., `_handleClick()`)

## Common Pitfalls & Anti-patterns

### ‚ùå DON'T: Forget TW Mixin

```typescript
export class MyComponent extends LitElement {} // ‚ùå No Tailwind
const TwLitElement = TW(LitElement);
export class MyComponent extends TwLitElement {} // ‚úÖ
```

### ‚ùå DON'T: Forget `super.connectedCallback()`

```typescript
connectedCallback() { this.doSomething(); }  // ‚ùå Breaks Lit
connectedCallback() { super.connectedCallback(); this.doSomething(); }  // ‚úÖ
```

### ‚ùå DON'T: Use `static styles` with Tailwind

```typescript
static styles = css`.btn { @apply bg-blue-500; }`;  // ‚ùå
render() { return html`<button class="bg-blue-500">`; }  // ‚úÖ
```

### ‚ùå DON'T: Forget `composed: true` on Events

```typescript
new CustomEvent("evt", { detail }); // ‚ùå Won't cross shadow DOM
new CustomEvent("evt", { detail, bubbles: true, composed: true }); // ‚úÖ
```

### ‚ùå DON'T: Forget Registry Entry

```typescript
// ‚ùå Created component but didn't add to registry.json
// Component won't be accessible via shadcn CLI

// ‚úÖ Add component to registry.json
```

### ‚ùå DON'T: Use Hardcoded Paths

```typescript
import { TW } from "../lib/tailwindMixin"; // ‚ùå Relative path
import { TW } from "@/registry/lib/tailwindMixin"; // ‚úÖ Use path alias
```

### ‚ùå DON'T: Store State in Controllers

```typescript
// ‚ùå Controller owns state - causes performance issues
export class MyController {
  private highlightedIndex = 0; // ‚ùå State in controller

  handleKeyDown() {
    this.highlightedIndex++;
    this.host.requestUpdate(); // ‚ùå Forces full re-render
  }
}

// ‚úÖ Host owns state - Lit's reactive system optimizes updates
export class MyComponent extends BaseElement {
  @state() private highlightedIndex = 0; // ‚úÖ State in host

  private controller = new MyController(this, {
    getHighlightedIndex: () => this.highlightedIndex,
    setHighlightedIndex: (index) => {
      this.highlightedIndex = index;
    },
  });
}
```

### ‚ùå DON'T: Forget to Update Controllers

```typescript
// ‚ùå Controller won't activate when state changes
override updated(changed: PropertyValues) {
  super.updated(changed);
  if (changed.has("open")) {
    // Missing controller.update()
  }
}

// ‚úÖ Always update controllers when relevant state changes
override updated(changed: PropertyValues) {
  super.updated(changed);
  if (changed.has("open")) {
    this.clickAway.update(); // ‚úÖ
    this.focusTrap.update(); // ‚úÖ
  }
}
```

### ‚ùå DON'T: Use Static Config for Reactive Properties

```typescript
// ‚ùå Loop value captured at construction time - won't update
private navigation = new MenuNavigationController(this, {
  loop: this.loop, // ‚ùå Static value
});

// ‚úÖ Use getter for runtime reactivity
private navigation = new MenuNavigationController(this, {
  loop: () => this.loop, // ‚úÖ Reactive getter
});
```

## Registry Workflow

### Adding a New Component

1. **Create component** in `registry/ui/my-component.ts`
2. **Create story** in `registry/ui/my-component.stories.ts`
3. **Add to registry.json** with metadata and file paths
4. **Build registry**: `bun run registry:build`
5. **Test in Storybook**: `bun run storybook`
6. **Test installation locally**:
   `npx shadcn@latest add http://localhost:3000/r/my-component.json`

## ‚ùì FAQ for Coding Agents

**Q: What if instructions conflict with README.md?**  
A: AGENTS.md takes precedence for agent tasks.

**Q: What's the difference between app/ and registry/?**  
A: `app/` is the Next.js website (React). `registry/` contains Lit web
components that users install via shadcn CLI.

**Q: Component not rendering in Storybook?**  
A: Ensure you import the component file (`import "./button";`), use correct
component tag name, and verify it's registered with `@customElement()`.

**Q: Tailwind classes not working?**  
A: Ensure component extends `TwLitElement`, classes in template (not
`static styles`).

**Q: How to add component dependencies?**  
A: Add npm dependencies in the `dependencies` array in `registry.json`. They'll
be installed when users add the component via shadcn CLI.

**Q: Changes not showing?**  
A: For Storybook: hot reload should work. For Next.js: hard refresh (Cmd/Ctrl +
Shift + R). For registry: run `bun run registry:build`.

**Q: Where do I put shared utilities?**  
A: Put them in `registry/lib/` and add to the `tailwind-mixin` registry item so
they're copied when users install components.

**Q: Should I create a new controller or use inline code?**  
A: Create a controller if the pattern is used in 2+ components OR if it involves
complex state management (keyboard navigation, focus trapping, etc.). Use inline
code for simple, component-specific logic.

**Q: How do I test controllers?**  
A: All controllers have unit tests in `@/controllers/*.test.ts`. Use Vitest with
mock hosts and DOM elements. See existing tests for patterns.

## Where to Find More Information

### Use These Tools for Detailed Documentation

**IMPORTANT**: Instead of duplicating documentation here, use these tools when
you need detailed information:

- **Context7** for library-specific docs: `/lit/lit`,
  `/tailwindlabs/tailwindcss`, `/storybookjs/storybook`
- **WebFetch** for official documentation:
  - Lit: https://lit.dev/docs/
  - Tailwind CSS v4: https://tailwindcss.com/docs
  - Storybook: https://storybook.js.org/docs
  - Shadcn CLI: https://ui.shadcn.com/docs/registry
  - Next.js: https://nextjs.org/docs
  - Vitest: https://vitest.dev/
  - Web Components:
    https://developer.mozilla.org/en-US/docs/Web/API/Web_components
  - TypeScript Decorators:
    https://www.typescriptlang.org/docs/handbook/decorators.html

### Project Files

- **README.md**: Human-readable project overview and setup guide
- **AGENTS.md** (this file): Agent-specific build, test, and style instructions
- **registry.json**: Source of truth for all registry components
- **package.json**: Dependencies and scripts
- **.storybook/main.ts**: Storybook configuration
- **next.config.ts**: Next.js configuration
- **tsconfig.json**: TypeScript configuration

## ‚ö†Ô∏è Important Notes

- **NEVER ASSUME OR GUESS** - When in doubt, ask for clarification
- **Two separate codebases** - `app/` is Next.js/React, `registry/` is Lit web
  components
- **Always extend TwLitElement** - Not plain LitElement (for Tailwind support in
  registry components)
- **Use TypeScript decorators** - `@customElement()`, `@property()`, `@state()`,
  etc.
- **Export component interfaces** - For type safety and Storybook args
- **Test in Storybook first** - Run `bun run storybook` to develop components
- **Update registry.json** - Every new component must be added to registry.json
- **Build registry** - Run `bun run registry:build` after registry.json changes
- **Use `cn()` for dynamic classes** - Don't concatenate strings
- **Always call super** - In lifecycle methods (connectedCallback, etc.)
- **Set `composed: true`** - For custom events that need to bubble out of shadow
  DOM
- **Declare custom elements** - In `HTMLElementTagNameMap` for TypeScript
- **Use path aliases** - Import from `@/registry/lib/` not relative paths
- **Add stories for all components** - Stories serve as documentation and visual
  tests
- **No Effect/Effect-Atom** - Use Lit's built-in `@state()` and `@property()`
  only
- **Use Reactive Controllers** - For reusable patterns (navigation, click-away,
  focus trap). See Reactive Controllers section above.
- **Controllers are stateless** - State belongs in host component with
  `@state()`
- **Update controllers in `updated()`** - Call `controller.update()` when
  relevant properties change
- **Test controllers** - All controllers must have unit tests in
  `@/controllers/*.test.ts`

## üîç Search Command Requirements

**CRITICAL**: Always use `rg` (ripgrep) for search operations:

```bash
# ‚úÖ Use rg for pattern searches
rg "pattern"

# ‚úÖ Use rg for file filtering
rg --files -g "*.ts"
rg --files -g "*.test.ts"
```

---

**üìù Keep this file current!** Update AGENTS.md whenever you add new scripts,
change test commands, or update code style rules. Treat it as living
documentation for all coding agents and future maintainers.

---

_Last updated: 2025-01-22_
